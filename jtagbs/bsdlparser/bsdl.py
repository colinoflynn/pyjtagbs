#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by Grako.
#
#    https://pypi.python.org/pypi/grako/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals

from grako.buffering import Buffer
from grako.parsing import graken, Parser
from grako.util import re, RE_FLAGS, generic_main  # noqa


KEYWORDS = {}


class bsdlBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re='--.*?$',
        ignorecase=True,
        namechars='',
        **kwargs
    ):
        super(bsdlBuffer, self).__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class bsdlParser(Parser):
    def __init__(
        self,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re='--.*?$',
        ignorecase=True,
        left_recursion=False,
        parseinfo=True,
        keywords=None,
        namechars='',
        buffer_class=bsdlBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super(bsdlParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            buffer_class=buffer_class,
            **kwargs
        )

    @graken()
    def _letters_(self):
        self._pattern(r'[A-Za-z]')

    @graken()
    def _digit_(self):
        self._pattern(r'[0-9]')

    @graken()
    def _vhdl_identifier_(self):
        self._pattern(r'[a-zA-Z][0-9a-zA-Z_]*')

    @graken()
    def _mnemonic_identifier_(self):
        self._pattern(r'[A-Za-z0-9\@\*\_\-\+\|\%\~\.]*[A-Za-z]+[A-Za-z0-9\@\*\_\-\+\|\%\~\.]*')

    @graken()
    def _prefix_identifier_(self):
        self._pattern(r'[a-zA-Z][a-zA-Z0-9_]*')

    @graken()
    def _integer_(self):
        self._pattern(r'[0-9]+')

    @graken()
    def _real_(self):
        self._pattern(r'[0-9]+\.[0-9]+([Ee][+-]?)?[0-9]*')

    @graken()
    def _pattern_(self):
        self._pattern(r'[01Xx]+')

    @graken()
    def _thirty_two_bit_pattern_(self):

        def sep0():
            self._token('&')

        def block0():
            self._pattern(r'[01Xx]+')
            self.name_last_node('@')
        self._gather(block0, sep0)

    @graken()
    def _binary_pattern_(self):
        self._pattern(r'0[bB][01xX][01xX_]*')

    @graken()
    def _hex_pattern_(self):
        self._pattern(r'0[xX][0-9a-fA-FxX][0-9a-fA-FxX_]*')

    @graken()
    def _decimal_pattern_(self):
        with self._choice():
            with self._option():
                self._pattern(r'[0-9]')
            with self._option():
                self._pattern(r'[1-9][0-9]+')
            self._error('expecting one of: [0-9] [1-9][0-9]+')

    @graken()
    def _string_(self):

        def sep0():
            self._token('&')

        def block0():
            with self._optional():
                self._quote_()
                self._pattern(r"[A-Za-z0-9\&'\(\)\[\]\*\,\-\+\.\:\;\<\=\>\_\/\t ]+")
                self.name_last_node('@')
                self._quote_()
        self._gather(block0, sep0)

    @graken()
    def _information_tag_(self):
        self._pattern(r"<[A-Za-z0-9\&'\(\)\[\]\*\,\-\+\.\:\;\=\_]+>")

    @graken()
    def _port_id_(self):
        with self._choice():
            with self._option():
                self._subscripted_port_name_()
            with self._option():
                self._port_name_()
            self._error('no available options')

    @graken()
    def _port_name_(self):
        self._vhdl_identifier_()

    @graken()
    def _subscripted_port_name_(self):
        self._port_name_()
        self._left_paren_()
        self._subscript_()
        self._right_paren_()

    @graken()
    def _subscript_(self):
        self._integer_()

    @graken()
    def _instruction_name_(self):
        with self._choice():
            with self._option():
                self._vhdl_identifier_()
            with self._option():
                self._token('BYPASS')
            with self._option():
                self._token('CLAMP')
            with self._option():
                self._token('EXTEST')
            with self._option():
                self._token('HIGHZ')
            with self._option():
                self._token('IDCODE')
            with self._option():
                self._token('INTEST')
            with self._option():
                self._token('PRELOAD')
            with self._option():
                self._token('RUNBIST')
            with self._option():
                self._token('SAMPLE')
            with self._option():
                self._token('USERCODE')
            with self._option():
                self._token('ECIDCODE')
            with self._option():
                self._token('CLAMP_HOLD')
            with self._option():
                self._token('CLAMP_RELEASE')
            with self._option():
                self._token('TMP_STATUS')
            with self._option():
                self._token('IC_RESET')
            with self._option():
                self._token('INIT_SETUP')
            with self._option():
                self._token('INIT_SETUP_CLAMP')
            with self._option():
                self._token('INIT_RUN')
            self._error('expecting one of: BYPASS CLAMP CLAMP_HOLD CLAMP_RELEASE ECIDCODE EXTEST HIGHZ IC_RESET IDCODE INIT_RUN INIT_SETUP INIT_SETUP_CLAMP INTEST PRELOAD RUNBIST SAMPLE TMP_STATUS USERCODE')

    @graken()
    def _bsdl_description_(self):
        self._token('entity')
        self._component_name_()
        self.name_last_node('component_name')
        self._token('is')
        self._generic_parameter_()
        self.name_last_node('generic_parameter')
        self._logical_port_description_()
        self.name_last_node('logical_port_description')
        self._standard_use_statement_()
        self.name_last_node('standard_use_statement')

        def block4():
            self._use_statement_()
            self.name_last_node('use_statement')
        self._closure(block4)
        self._component_conformance_statement_()
        self.name_last_node('component_conformance_statement')
        self._device_package_pin_mappings_()
        self.name_last_node('device_package_pin_mappings')
        with self._optional():
            self._grouped_port_identification_()
            self.name_last_node('grouped_port_identification')
        self._scan_port_identification_()
        self.name_last_node('scan_port_identification')
        with self._optional():
            self._compliance_enable_description_()
            self.name_last_node('compliance_enable_description')
        self._instruction_register_description_()
        self.name_last_node('instruction_register_description')
        with self._optional():
            self._optional_register_description_()
            self.name_last_node('optional_register_description')
        with self._optional():
            self._register_access_description_()
            self.name_last_node('register_access_description')
        self._boundary_scan_register_description_()
        self.name_last_node('boundary_scan_register_description')
        with self._optional():
            self._runbist_description_()
            self.name_last_node('runbist_description')
        with self._optional():
            self._intest_description_()
            self.name_last_node('intest_description')
        with self._optional():
            self._system_clock_description_()
            self.name_last_node('system_clock_description')

        def block18():
            self._register_mnemonics_description_()
            self.name_last_node('register_mnemonics_description')
        self._closure(block18)

        def block20():
            self._register_fields_description_()
            self.name_last_node('register_fields_description')
        self._closure(block20)

        def block22():
            self._register_assembly_description_()
            self.name_last_node('register_assembly_description')
        self._closure(block22)

        def block24():
            self._register_constraints_description_()
            self.name_last_node('register_constraints_description')
        self._closure(block24)

        def block26():
            self._register_association_description_()
            self.name_last_node('register_association_description')
        self._closure(block26)

        def block28():
            self._power_port_association_description_()
            self.name_last_node('power_port_association_description')
        self._closure(block28)

        def block30():
            self._bsdl_extensions_()
            self.name_last_node('bsdl_extensions')
        self._closure(block30)
        with self._optional():
            self._design_warning_()
            self.name_last_node('design_warning')
        self._token('end')
        self._component_name_()
        self._semicolon_()
        self.ast._define(
            ['boundary_scan_register_description', 'bsdl_extensions', 'compliance_enable_description', 'component_conformance_statement', 'component_name', 'design_warning', 'device_package_pin_mappings', 'generic_parameter', 'grouped_port_identification', 'instruction_register_description', 'intest_description', 'logical_port_description', 'optional_register_description', 'power_port_association_description', 'register_access_description', 'register_assembly_description', 'register_association_description', 'register_constraints_description', 'register_fields_description', 'register_mnemonics_description', 'runbist_description', 'scan_port_identification', 'standard_use_statement', 'system_clock_description', 'use_statement'],
            []
        )

    @graken()
    def _component_name_(self):
        self._vhdl_identifier_()

    @graken()
    def _generic_parameter_(self):
        with self._choice():
            with self._option():
                self._generic_default_()
            with self._option():
                self._generic_no_default_()
            self._error('no available options')

    @graken()
    def _generic_default_(self):
        self._token('generic')
        self._left_paren_()
        self._token('PHYSICAL_PIN_MAP')
        self._colon_()
        self._token('string')
        self._right_paren_()
        self._semicolon_()

    @graken()
    def _generic_no_default_(self):
        self._token('generic')
        self._left_paren_()
        self._token('PHYSICAL_PIN_MAP')
        self._colon_()
        self._token('string')
        self._colon_equal_()
        self._default_device_package_type_()
        self.name_last_node('default_device_package_type')
        self._right_paren_()
        self._semicolon_()
        self.ast._define(
            ['default_device_package_type'],
            []
        )

    @graken()
    def _default_device_package_type_(self):
        self._quote_()
        self._pin_mapping_name_()
        self.name_last_node('@')
        self._quote_()

    @graken()
    def _logical_port_description_(self):
        self._token('port')
        self._left_paren_()

        def sep0():
            with self._group():
                self._semicolon_()

        def block0():
            with self._optional():
                self._pin_spec_()
                self.add_last_node_to_name('@')
        self._gather(block0, sep0)
        self._right_paren_()
        self._semicolon_()

    @graken()
    def _pin_spec_(self):
        self._identifier_list_()
        self.name_last_node('identifier_list')
        self._colon_()
        self._pin_type_()
        self.name_last_node('pin_type')
        self._port_dimension_()
        self.name_last_node('port_dimension')
        self.ast._define(
            ['identifier_list', 'pin_type', 'port_dimension'],
            []
        )

    @graken()
    def _identifier_list_(self):

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._port_name_()
        self._gather(block0, sep0)

    @graken()
    def _pin_type_(self):
        with self._choice():
            with self._option():
                self._token('in')
            with self._option():
                self._token('out')
            with self._option():
                self._token('buffer')
            with self._option():
                self._token('inout')
            with self._option():
                self._token('LINKAGE_INOUT')
            with self._option():
                self._token('LINKAGE_BUFFER')
            with self._option():
                self._token('LINKAGE_IN')
            with self._option():
                self._token('LINKAGE_OUT')
            with self._option():
                self._token('LINKAGE_MECHANICAL')
            with self._option():
                self._token('POWER_0')
            with self._option():
                self._token('POWER_POS')
            with self._option():
                self._token('POWER_NEG')
            with self._option():
                self._token('VREF_IN')
            with self._option():
                self._token('VREF_OUT')
            with self._option():
                self._token('linkage')
            self._error('expecting one of: LINKAGE_BUFFER LINKAGE_IN LINKAGE_INOUT LINKAGE_MECHANICAL LINKAGE_OUT POWER_0 POWER_NEG POWER_POS VREF_IN VREF_OUT buffer in inout linkage out')

    @graken()
    def _port_dimension_(self):
        with self._choice():
            with self._option():
                self._bit_vector_spec_()
            with self._option():
                self._token('bit')
            self._error('expecting one of: bit')

    @graken()
    def _bit_vector_spec_(self):
        self._token('bit_vector')
        self._left_paren_()
        self._range_()
        self.name_last_node('bit_vector')
        self._right_paren_()
        self.ast._define(
            ['bit_vector'],
            []
        )

    @graken()
    def _range_(self):
        with self._choice():
            with self._option():
                self._up_range_()
            with self._option():
                self._down_range_()
            self._error('no available options')

    @graken()
    def _up_range_(self):
        self._integer1_()
        self._token('to')
        self._integer2_()

    @graken()
    def _down_range_(self):
        self._integer2_()
        self._token('downto')
        self._integer1_()

    @graken()
    def _integer1_(self):
        self._integer_()

    @graken()
    def _integer2_(self):
        self._integer_()

    @graken()
    def _standard_use_statement_(self):
        self._token('use')
        self._standard_package_name_()
        self.name_last_node('@')
        self._period_()
        self._token('all')
        self._semicolon_()

    @graken()
    def _standard_package_name_(self):
        with self._choice():
            with self._option():
                self._token('STD_1149_1_1990')
            with self._option():
                self._token('STD_1149_1_1994')
            with self._option():
                self._token('STD_1149_1_2001')
            with self._option():
                self._token('STD_1149_1_2013')
            self._error('expecting one of: STD_1149_1_1990 STD_1149_1_1994 STD_1149_1_2001 STD_1149_1_2013')

    @graken()
    def _use_statement_(self):
        self._token('use')
        self._user_package_name_()
        self.name_last_node('@')
        self._period_()
        self._token('all')
        self._semicolon_()

    @graken()
    def _user_package_name_(self):
        self._vhdl_identifier_()

    @graken()
    def _component_conformance_statement_(self):
        self._token('attribute')
        self._token('COMPONENT_CONFORMANCE')
        self._token('of')
        self._component_name_()
        self._colon_()
        self._token('entity')
        self._token('is')
        self._conformance_string_()
        self.name_last_node('@')
        self._semicolon_()

    @graken()
    def _conformance_string_(self):
        self._quote_()
        self._conformance_identification_()
        self.name_last_node('@')
        self._quote_()

    @graken()
    def _conformance_identification_(self):
        with self._choice():
            with self._option():
                self._token('STD_1149_1_1990')
            with self._option():
                self._token('STD_1149_1_1993')
            with self._option():
                self._token('STD_1149_1_2001')
            with self._option():
                self._token('STD_1149_1_2013')
            self._error('expecting one of: STD_1149_1_1990 STD_1149_1_1993 STD_1149_1_2001 STD_1149_1_2013')

    @graken()
    def _device_package_pin_mappings_(self):
        self._pin_map_statement_()
        self._pin_mappings_()
        self.name_last_node('@')

    @graken()
    def _pin_map_statement_(self):
        self._token('attribute')
        self._token('PIN_MAP')
        self._token('of')
        self._component_name_()
        self._colon_()
        self._token('entity')
        self._token('is')
        self._token('PHYSICAL_PIN_MAP')
        self._semicolon_()

    @graken()
    def _pin_mappings_(self):

        def block0():
            self._pin_mapping_()
        self._positive_closure(block0)

    @graken()
    def _pin_mapping_(self):
        self._token('constant')
        self._pin_mapping_name_()
        self.name_last_node('pin_mapping_name')
        self._colon_()
        self._token('PIN_MAP_STRING')
        self._token(':=')
        self._map_string_()
        self.name_last_node('pin_map')
        self._semicolon_()
        self.ast._define(
            ['pin_map', 'pin_mapping_name'],
            []
        )

    @graken()
    def _pin_mapping_name_(self):
        self._vhdl_identifier_()

    @graken()
    def _map_string_(self):
        self._string_()

    @graken()
    def _port_map_(self):

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._port_()
        self._gather(block0, sep0)

    @graken()
    def _port_(self):
        self._port_name_()
        self.name_last_node('port_name')
        self._colon_()
        self._pin_or_list_()
        self.name_last_node('pin_list')
        self.ast._define(
            ['pin_list', 'port_name'],
            []
        )

    @graken()
    def _pin_or_list_(self):
        with self._choice():
            with self._option():
                self._pin_desc_()
                self.add_last_node_to_name('@')
            with self._option():
                self._pin_list_()
                self.name_last_node('@')
            self._error('no available options')

    @graken()
    def _pin_list_(self):
        self._left_paren_()

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._pin_desc_()
                self.name_last_node('@')
        self._gather(block0, sep0)
        self._right_paren_()

    @graken()
    def _pin_desc_(self):
        with self._choice():
            with self._option():
                self._token('OPEN')
            with self._option():
                self._token('TIE0')
            with self._option():
                self._token('TIE1')
            with self._option():
                self._pin_id_()
            self._error('expecting one of: OPEN TIE0 TIE1')

    @graken()
    def _pin_id_(self):
        with self._choice():
            with self._option():
                self._integer_()
            with self._option():
                self._vhdl_identifier_()
            self._error('no available options')

    @graken()
    def _grouped_port_identification_(self):
        self._token('attribute')
        self._token('PORT_GROUPING')
        self._token('of')
        self._component_name_()
        self._colon_()
        self._token('entity')
        self._token('is')
        self._group_table_string_()
        self.name_last_node('@')
        self._semicolon_()

    @graken()
    def _group_table_string_(self):
        self._string_()

    @graken()
    def _group_table_(self):

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._twin_group_entry_()
        self._gather(block0, sep0)

    @graken()
    def _twin_group_entry_(self):
        self._twin_group_type_()
        self.name_last_node('twin_group_type')
        self._left_paren_()
        self._twin_group_list_()
        self.name_last_node('twin_group_list')
        self._right_paren_()
        self.ast._define(
            ['twin_group_list', 'twin_group_type'],
            []
        )

    @graken()
    def _twin_group_type_(self):
        with self._choice():
            with self._option():
                self._token('DIFFERENTIAL_VOLTAGE')
            with self._option():
                self._token('DIFFERENTIAL_CURRENT')
            self._error('expecting one of: DIFFERENTIAL_CURRENT DIFFERENTIAL_VOLTAGE')

    @graken()
    def _twin_group_list_(self):

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._twin_group_()
        self._gather(block0, sep0)

    @graken()
    def _twin_group_(self):
        self._left_paren_()
        self._representative_port_()
        self.name_last_node('representative_port')
        self._comma_()
        self._associated_port_()
        self.name_last_node('associated_port')
        self._right_paren_()
        self.ast._define(
            ['associated_port', 'representative_port'],
            []
        )

    @graken()
    def _representative_port_(self):
        self._port_id_()

    @graken()
    def _associated_port_(self):
        self._port_id_()

    @graken()
    def _scan_port_identification_(self):

        def block0():
            self._scan_port_stmt_()
        self._positive_closure(block0)

    @graken()
    def _scan_port_stmt_(self):
        with self._choice():
            with self._option():
                self._tck_stmt_()
                self.name_last_node('@')
            with self._option():
                self._tdi_stmt_()
                self.name_last_node('@')
            with self._option():
                self._tms_stmt_()
                self.name_last_node('@')
            with self._option():
                self._tdo_stmt_()
                self.name_last_node('@')
            with self._option():
                self._trst_stmt_()
                self.name_last_node('@')
            self._error('no available options')

    @graken()
    def _tck_stmt_(self):
        self._token('attribute')
        self._token('TAP_SCAN_CLOCK')
        self._token('of')
        self._port_id_()
        self._colon_()
        self._token('signal')
        self._token('is')
        self._left_paren_()
        self._clock_record_()
        self.name_last_node('tap_scan_clock')
        self._right_paren_()
        self._semicolon_()
        self.ast._define(
            ['tap_scan_clock'],
            []
        )

    @graken()
    def _tdi_stmt_(self):
        self._token('attribute')
        self._token('TAP_SCAN_IN')
        self._token('of')
        self._port_id_()
        self._colon_()
        self._token('signal')
        self._token('is')
        self._token('true')
        self.name_last_node('tap_scan_in')
        self._semicolon_()
        self.ast._define(
            ['tap_scan_in'],
            []
        )

    @graken()
    def _tms_stmt_(self):
        self._token('attribute')
        self._token('TAP_SCAN_MODE')
        self._token('of')
        self._port_id_()
        self._colon_()
        self._token('signal')
        self._token('is')
        self._token('true')
        self.name_last_node('tap_scan_mode')
        self._semicolon_()
        self.ast._define(
            ['tap_scan_mode'],
            []
        )

    @graken()
    def _tdo_stmt_(self):
        self._token('attribute')
        self._token('TAP_SCAN_OUT')
        self._token('of')
        self._port_id_()
        self._colon_()
        self._token('signal')
        self._token('is')
        self._token('true')
        self.name_last_node('tap_scan_out')
        self._semicolon_()
        self.ast._define(
            ['tap_scan_out'],
            []
        )

    @graken()
    def _trst_stmt_(self):
        self._token('attribute')
        self._token('TAP_SCAN_RESET')
        self._token('of')
        self._port_id_()
        self._colon_()
        self._token('signal')
        self._token('is')
        self._token('true')
        self.name_last_node('tap_scan_reset')
        self._semicolon_()
        self.ast._define(
            ['tap_scan_reset'],
            []
        )

    @graken()
    def _clock_record_(self):
        self._real_()
        self.name_last_node('frequency')
        self._comma_()
        self._halt_state_value_()
        self.name_last_node('halt_value')
        self.ast._define(
            ['frequency', 'halt_value'],
            []
        )

    @graken()
    def _halt_state_value_(self):
        with self._choice():
            with self._option():
                self._token('LOW')
            with self._option():
                self._token('BOTH')
            self._error('expecting one of: BOTH LOW')

    @graken()
    def _compliance_enable_description_(self):
        self._token('attribute')
        self._token('COMPLIANCE_PATTERNS')
        self._token('of')
        self._component_name_()
        self._colon_()
        self._token('entity')
        self._token('is')
        self._compliance_pattern_string_()
        self.name_last_node('compliance_patterns')
        self._semicolon_()
        self.ast._define(
            ['compliance_patterns'],
            []
        )

    @graken()
    def _compliance_pattern_string_(self):

        def sep0():
            self._token('&')

        def block0():
            self._quote_()
            self._left_paren_()
            self._compliance_port_list_()
            self.name_last_node('compliance_port_list')
            self._right_paren_()
            self._left_paren_()
            self._pattern_list_()
            self.name_last_node('pattern_list')
            self._right_paren_()
            self._quote_()
        self._gather(block0, sep0)
        self.ast._define(
            ['compliance_port_list', 'pattern_list'],
            []
        )

    @graken()
    def _compliance_port_list_(self):

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._port_id_()
        self._gather(block0, sep0)

    @graken()
    def _pattern_list_(self):

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._pattern_()
        self._gather(block0, sep0)

    @graken()
    def _instruction_register_description_(self):
        self._instruction_length_stmt_()
        self.name_last_node('instruction_length')
        self._instruction_opcode_stmt_()
        self.name_last_node('instruction_opcodes')
        self._instruction_capture_stmt_()
        self.name_last_node('instruction_capture')
        with self._optional():
            self._instruction_private_stmt_()
            self.name_last_node('instruction_private')
        self.ast._define(
            ['instruction_capture', 'instruction_length', 'instruction_opcodes', 'instruction_private'],
            []
        )

    @graken()
    def _instruction_length_stmt_(self):
        self._token('attribute')
        self._token('INSTRUCTION_LENGTH')
        self._token('of')
        self._component_name_()
        self._colon_()
        self._token('entity')
        self._token('is')
        self._integer_()
        self.name_last_node('@')
        self._semicolon_()

    @graken()
    def _instruction_opcode_stmt_(self):
        self._token('attribute')
        self._token('INSTRUCTION_OPCODE')
        self._token('of')
        self._component_name_()
        self._colon_()
        self._token('entity')
        self._token('is')
        self._opcode_table_string_()
        self.name_last_node('@')
        self._semicolon_()

    @graken()
    def _instruction_capture_stmt_(self):
        self._token('attribute')
        self._token('INSTRUCTION_CAPTURE')
        self._token('of')
        self._component_name_()
        self._colon_()
        self._token('entity')
        self._token('is')
        self._pattern_list_string_()
        self.name_last_node('@')
        self._semicolon_()

    @graken()
    def _instruction_private_stmt_(self):
        self._token('attribute')
        self._token('INSTRUCTION_PRIVATE')
        self._token('of')
        self._component_name_()
        self._colon_()
        self._token('entity')
        self._token('is')
        self._instruction_list_string_()
        self.name_last_node('@')
        self._semicolon_()

    @graken()
    def _opcode_table_string_(self):

        def sep0():
            self._token('&')

        def block0():
            self._quote_()

            def sep1():
                with self._group():
                    self._comma_()

            def block1():
                with self._optional():
                    self._opcode_description_()
                    self.add_last_node_to_name('@')
            self._gather(block1, sep1)
            self._quote_()
        self._gather(block0, sep0)

    @graken()
    def _opcode_description_(self):
        self._instruction_name_()
        self.name_last_node('instruction_name')
        self._left_paren_()
        self._opcode_list_()
        self.name_last_node('opcode_list')
        self._right_paren_()
        self.ast._define(
            ['instruction_name', 'opcode_list'],
            []
        )

    @graken()
    def _opcode_list_(self):

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._opcode_()
                self.add_last_node_to_name('@')
        self._gather(block0, sep0)

    @graken()
    def _opcode_(self):
        self._pattern_()

    @graken()
    def _pattern_list_string_(self):

        def sep0():
            self._token('&')

        def block0():
            self._quote_()
            self._opcode_list_()
            self.name_last_node('@')
            self._quote_()
        self._gather(block0, sep0)

    @graken()
    def _instruction_list_string_(self):

        def sep0():
            self._token('&')

        def block0():
            self._quote_()
            self._instruction_list_()
            self.name_last_node('@')
            self._quote_()
        self._gather(block0, sep0)

    @graken()
    def _instruction_list_(self):

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._instruction_name_()
                self.name_last_node('@')
        self._gather(block0, sep0)

    @graken()
    def _optional_register_description_(self):
        self._optional_register_stmt_()
        with self._optional():
            self._optional_register_stmt_()

    @graken()
    def _optional_register_stmt_(self):
        with self._choice():
            with self._option():
                self._idcode_statement_()
            with self._option():
                self._usercode_statement_()
            self._error('no available options')

    @graken()
    def _idcode_statement_(self):
        self._token('attribute')
        self._token('IDCODE_REGISTER')
        self._token('of')
        self._component_name_()
        self._colon_()
        self._token('entity')
        self._token('is')

        def sep0():
            self._token('&')

        def block0():
            self._quote_()
            self._thirty_two_bit_pattern_list_()
            self.name_last_node('idcode_register')
            self._quote_()
        self._gather(block0, sep0)
        self._semicolon_()
        self.ast._define(
            ['idcode_register'],
            []
        )

    @graken()
    def _usercode_statement_(self):
        self._token('attribute')
        self._token('USERCODE_REGISTER')
        self._token('of')
        self._component_name_()
        self._colon_()
        self._token('entity')
        self._token('is')

        def sep0():
            self._token('&')

        def block0():
            self._quote_()
            self._thirty_two_bit_pattern_list_()
            self.name_last_node('usercode_register')
            self._quote_()
        self._gather(block0, sep0)
        self._semicolon_()
        self.ast._define(
            ['usercode_register'],
            []
        )

    @graken()
    def _thirty_two_bit_pattern_list_(self):

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._thirty_two_bit_pattern_()
                self.name_last_node('@')
        self._gather(block0, sep0)

    @graken()
    def _register_access_description_(self):
        self._token('attribute')
        self._token('REGISTER_ACCESS')
        self._token('of')
        self._component_name_()
        self._colon_()
        self._token('entity')
        self._token('is')
        self._register_access_string_()
        self.name_last_node('@')
        self._semicolon_()

    @graken()
    def _register_access_string_(self):

        def sep0():
            self._token('&')

        def block0():
            self._quote_()

            def sep1():
                with self._group():
                    self._comma_()

            def block1():
                with self._optional():
                    self._register_association_()
                    self.add_last_node_to_name('@')
            self._gather(block1, sep1)
            self._quote_()
        self._gather(block0, sep0)

    @graken()
    def _register_association_(self):
        self._register_()
        self.name_last_node('register')
        self._left_paren_()
        self._instruction_capture_list_()
        self.name_last_node('instruction_capture_list')
        self._right_paren_()
        self.ast._define(
            ['instruction_capture_list', 'register'],
            []
        )

    @graken()
    def _instruction_capture_list_(self):

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._instruction_capture_()
        self._gather(block0, sep0)

    @graken()
    def _instruction_capture_(self):
        self._instruction_name_()
        self.name_last_node('instruction_name')
        with self._optional():
            self._token('CAPTURES')
            self._pattern_()
            self.name_last_node('pattern')
        self.ast._define(
            ['instruction_name', 'pattern'],
            []
        )

    @graken()
    def _register_(self):
        with self._choice():
            with self._option():
                self._std_fixed_register_()
                self.name_last_node('reg_name')
            with self._option():
                self._std_var_register_()
                self.name_last_node('@')
            with self._option():
                self._design_specific_register_()
                self.name_last_node('@')
            self._error('no available options')
        self.ast._define(
            ['reg_name'],
            []
        )

    @graken()
    def _std_fixed_register_(self):
        with self._choice():
            with self._option():
                self._token('BOUNDARY')
            with self._option():
                self._token('BYPASS')
            with self._option():
                self._token('DEVICE_ID')
            with self._option():
                self._token('TMP_STATUS')
            self._error('expecting one of: BOUNDARY BYPASS DEVICE_ID TMP_STATUS')

    @graken()
    def _std_var_register_(self):
        self._std_var_reg_name_()
        self.name_last_node('reg_name')
        with self._optional():
            self._left_bracket_()
            self._reg_length_()
            self.name_last_node('reg_length')
            self._right_bracket_()
        self.ast._define(
            ['reg_length', 'reg_name'],
            []
        )

    @graken()
    def _std_var_reg_name_(self):
        with self._choice():
            with self._option():
                self._token('ECID')
            with self._option():
                self._token('INIT_DATA')
            with self._option():
                self._token('INIT_STATUS')
            with self._option():
                self._token('RESET_SELECT')
            self._error('expecting one of: ECID INIT_DATA INIT_STATUS RESET_SELECT')

    @graken()
    def _design_specific_register_(self):
        self._vhdl_identifier_()
        self.name_last_node('reg_name')
        with self._optional():
            self._left_bracket_()
            self._reg_length_()
            self.name_last_node('reg_length')
            self._right_bracket_()
        self.ast._define(
            ['reg_length', 'reg_name'],
            []
        )

    @graken()
    def _reg_length_(self):
        with self._choice():
            with self._option():
                self._integer_()
            with self._option():
                self._asterisk_()
            self._error('no available options')

    @graken()
    def _boundary_scan_register_description_(self):
        with self._choice():
            with self._option():
                self._fixed_boundary_stmts_()
                self.name_last_node('fixed_boundary_stmts')
            with self._option():
                self._segment_boundary_stmts_()
                self.name_last_node('segment_boundary_stmts')
            self._error('no available options')
        self.ast._define(
            ['fixed_boundary_stmts', 'segment_boundary_stmts'],
            []
        )

    @graken()
    def _fixed_boundary_stmts_(self):
        self._boundary_length_stmt_()
        self.name_last_node('boundary_length')
        self._boundary_register_stmt_()
        self.name_last_node('boundary_register')
        self.ast._define(
            ['boundary_length', 'boundary_register'],
            []
        )

    @graken()
    def _segment_boundary_stmts_(self):
        self._assembled_boundary_length_stmt_()
        self.name_last_node('assembled_boundary_length')
        self._boundary_register_segments_()
        self.name_last_node('boundary_register_segments')
        self.ast._define(
            ['assembled_boundary_length', 'boundary_register_segments'],
            []
        )

    @graken()
    def _boundary_length_stmt_(self):
        self._token('attribute')
        self._token('BOUNDARY_LENGTH')
        self._token('of')
        self._component_name_()
        self._colon_()
        self._token('entity')
        self._token('is')
        self._register_length_()
        self.name_last_node('@')
        self._semicolon_()

    @graken()
    def _register_length_(self):
        self._integer_()

    @graken()
    def _boundary_register_stmt_(self):
        self._token('attribute')
        self._token('BOUNDARY_REGISTER')
        self._token('of')
        self._component_name_()
        self._colon_()
        self._token('entity')
        self._token('is')
        self._cell_table_string_()
        self.name_last_node('@')
        self._semicolon_()

    @graken()
    def _cell_table_string_(self):

        def sep0():
            self._token('&')

        def block0():
            self._quote_()
            self._cell_table_()
            self.name_last_node('@')
            self._quote_()
        self._gather(block0, sep0)

    @graken()
    def _assembled_boundary_length_stmt_(self):
        self._token('attribute')
        self._token('ASSEMBLED_BOUNDARY_LENGTH')
        self._token('of')
        self._component_name_()
        self._colon_()
        self._token('entity')
        self._token('is')
        self._left_paren_()
        self._reset_length_()
        self.name_last_node('reset_length')
        self._comma_()
        self._register_length_()
        self.name_last_node('boundary_length')
        self._right_paren_()
        self._semicolon_()
        self.ast._define(
            ['boundary_length', 'reset_length'],
            []
        )

    @graken()
    def _reset_length_(self):
        self._integer_()

    @graken()
    def _boundary_register_segments_(self):

        def block0():
            self._boundary_register_segment_()
        self._positive_closure(block0)

    @graken()
    def _boundary_register_segment_(self):
        self._token('attribute')
        self._token('BOUNDARY_SEGMENT')
        self._token('of')
        self._component_name_()
        self._colon_()
        self._token('entity')
        self._token('is')
        self._boundary_segment_string_()
        self.name_last_node('boundary_segment')
        self._semicolon_()
        self.ast._define(
            ['boundary_segment'],
            []
        )

    @graken()
    def _boundary_segment_string_(self):

        def sep0():
            self._token('&')

        def block0():
            self._quote_()

            def sep1():
                with self._group():
                    self._comma_()

            def block1():
                with self._optional():
                    self._boundary_segment_list_()
                    self.add_last_node_to_name('@')
            self._gather(block1, sep1)
            self._quote_()
        self._gather(block0, sep0)

    @graken()
    def _boundary_segment_list_(self):
        self._boundary_segment_name_()
        self.name_last_node('segment_name')
        self._left_bracket_()
        self._boundary_segment_length_()
        self.name_last_node('segment_length')
        self._right_bracket_()
        self._left_paren_()
        self._cell_table_()
        self.name_last_node('cell_table')
        self._right_paren_()
        self.ast._define(
            ['cell_table', 'segment_length', 'segment_name'],
            []
        )

    @graken()
    def _boundary_segment_name_(self):
        self._vhdl_identifier_()

    @graken()
    def _boundary_segment_length_(self):
        self._integer_()

    @graken()
    def _cell_table_(self):

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._cell_entry_()
                self.name_last_node('@')
        self._gather(block0, sep0)

    @graken()
    def _cell_entry_(self):
        self._cell_number_()
        self.name_last_node('cell_number')
        self._left_paren_()
        self._cell_info_()
        self.name_last_node('cell_info')
        self._right_paren_()
        self.ast._define(
            ['cell_info', 'cell_number'],
            []
        )

    @graken()
    def _cell_number_(self):
        self._integer_()

    @graken()
    def _cell_info_(self):
        self._cell_spec_()
        self.name_last_node('cell_spec')
        with self._optional():
            self._comma_()
            self._input_or_disable_spec_()
            self.name_last_node('input_or_disable_spec')
        self.ast._define(
            ['cell_spec', 'input_or_disable_spec'],
            []
        )

    @graken()
    def _cell_spec_(self):
        self._cell_name_()
        self.name_last_node('cell_name')
        self._comma_()
        self._port_id_or_null_()
        self.name_last_node('port_id')
        self._comma_()
        self._function_()
        self.name_last_node('function')
        self._comma_()
        self._safe_bit_()
        self.name_last_node('safe_bit')
        self.ast._define(
            ['cell_name', 'function', 'port_id', 'safe_bit'],
            []
        )

    @graken()
    def _cell_name_(self):
        self._vhdl_identifier_()

    @graken()
    def _port_id_or_null_(self):
        with self._choice():
            with self._option():
                self._port_id_()
            with self._option():
                self._asterisk_()
            self._error('no available options')

    @graken()
    def _function_(self):
        with self._choice():
            with self._option():
                self._token('INPUT')
            with self._option():
                self._token('OUTPUT2')
            with self._option():
                self._token('OUTPUT3')
            with self._option():
                self._token('CONTROL')
            with self._option():
                self._token('CONTROLR')
            with self._option():
                self._token('INTERNAL')
            with self._option():
                self._token('CLOCK')
            with self._option():
                self._token('BIDIR')
            with self._option():
                self._token('OBSERVE_ONLY')
            self._error('expecting one of: BIDIR CLOCK CONTROL CONTROLR INPUT INTERNAL OBSERVE_ONLY OUTPUT2 OUTPUT3')

    @graken()
    def _safe_bit_(self):
        with self._choice():
            with self._option():
                self._token('0')
            with self._option():
                self._token('1')
            with self._option():
                self._token('X')
            self._error('expecting one of: 0 1 X')

    @graken()
    def _input_or_disable_spec_(self):
        with self._choice():
            with self._option():
                self._input_spec_()
            with self._option():
                self._disable_spec_()
            self._error('no available options')

    @graken()
    def _input_spec_(self):
        with self._choice():
            with self._option():
                self._token('EXTERN0')
            with self._option():
                self._token('EXTERN1')
            with self._option():
                self._token('PULL0')
            with self._option():
                self._token('PULL1')
            with self._option():
                self._token('OPEN0')
            with self._option():
                self._token('OPEN1')
            with self._option():
                self._token('KEEPER')
            with self._option():
                self._token('OPENX')
            with self._option():
                self._token('EXPECT1')
            with self._option():
                self._token('EXPECT0')
            self._error('expecting one of: EXPECT0 EXPECT1 EXTERN0 EXTERN1 KEEPER OPEN0 OPEN1 OPENX PULL0 PULL1')

    @graken()
    def _disable_spec_(self):
        self._ccell_()
        self.name_last_node('control_cell')
        self._comma_()
        self._disable_value_()
        self.name_last_node('disable_value')
        self._comma_()
        self._disable_result_()
        self.name_last_node('disable_result')
        self.ast._define(
            ['control_cell', 'disable_result', 'disable_value'],
            []
        )

    @graken()
    def _ccell_(self):
        self._integer_()

    @graken()
    def _disable_value_(self):
        with self._choice():
            with self._option():
                self._token('0')
            with self._option():
                self._token('1')
            self._error('expecting one of: 0 1')

    @graken()
    def _disable_result_(self):
        with self._choice():
            with self._option():
                self._token('WEAK0')
            with self._option():
                self._token('WEAK1')
            with self._option():
                self._token('PULL0')
            with self._option():
                self._token('PULL1')
            with self._option():
                self._token('OPEN0')
            with self._option():
                self._token('OPEN1')
            with self._option():
                self._token('KEEPER')
            with self._option():
                self._token('Z')
            self._error('expecting one of: KEEPER OPEN0 OPEN1 PULL0 PULL1 WEAK0 WEAK1 Z')

    @graken()
    def _runbist_description_(self):
        self._token('attribute')
        self._token('RUNBIST_EXECUTION')
        self._token('of')
        self._component_name_()
        self._colon_()
        self._token('entity')
        self._token('is')

        def sep0():
            self._token('&')

        def block0():
            self._quote_()
            self._runbist_spec_()
            self._quote_()
        self._gather(block0, sep0)
        self._semicolon_()

    @graken()
    def _runbist_spec_(self):
        self._wait_spec_()
        self._comma_()
        self._pin_state_()
        self._comma_()
        self._signature_spec_()

    @graken()
    def _wait_spec_(self):
        self._token('WAIT_DURATION')
        self._left_paren_()
        self._duration_spec_()
        self._right_paren_()

    @graken()
    def _duration_spec_(self):
        with self._choice():
            with self._option():
                self._clock_cycles_list_()
            with self._option():
                self._time_and_clocks_()
            self._error('no available options')

    @graken()
    def _time_and_clocks_(self):
        self._time_()
        with self._optional():
            self._comma_()
            self._clock_cycles_list_()

    @graken()
    def _clock_cycles_list_(self):

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._clock_cycles_()
        self._gather(block0, sep0)

    @graken()
    def _time_(self):
        self._real_()

    @graken()
    def _clock_cycles_(self):
        self._port_id_()
        self._integer_()

    @graken()
    def _pin_state_(self):
        self._token('OBSERVING')
        self._condition_()
        self._token('AT_PINS')

    @graken()
    def _condition_(self):
        with self._choice():
            with self._option():
                self._token('HIGHZ')
            with self._option():
                self._token('BOUNDARY')
            self._error('expecting one of: BOUNDARY HIGHZ')

    @graken()
    def _signature_spec_(self):
        self._token('EXPECT_DATA')
        self._det_pattern_()

    @graken()
    def _det_pattern_(self):

        def block0():
            self._bit_()
        self._positive_closure(block0)

    @graken()
    def _bit_(self):
        with self._choice():
            with self._option():
                self._token('0')
            with self._option():
                self._token('1')
            self._error('expecting one of: 0 1')

    @graken()
    def _intest_description_(self):
        self._token('attribute')
        self._token('INTEST_EXECUTION')
        self._token('of')
        self._component_name_()
        self._colon_()
        self._token('entity')
        self._token('is')

        def sep0():
            self._token('&')

        def block0():
            self._quote_()
            self._intest_spec_()
            self._quote_()
        self._gather(block0, sep0)
        self._semicolon_()

    @graken()
    def _intest_spec_(self):
        self._wait_spec_()
        self._comma_()
        self._pin_state_()

    @graken()
    def _system_clock_description_(self):
        self._token('attribute')
        self._token('SYSCLOCK_REQUIREMENTS')
        self._token('of')
        self._entity_target_()
        self._token('is')
        self._system_clock_description_string_()
        self._semicolon_()

    @graken()
    def _system_clock_description_string_(self):

        def sep0():
            self._token('&')

        def block0():
            self._quote_()

            def sep1():
                with self._group():
                    self._comma_()

            def block1():
                with self._optional():
                    self._system_clock_requirement_()
            self._gather(block1, sep1)
            self._quote_()
        self._gather(block0, sep0)

    @graken()
    def _system_clock_requirement_(self):
        self._left_paren_()
        self._port_id_()
        self._comma_()
        self._min_freq_()
        self._comma_()
        self._max_freq_()
        self._comma_()
        self._clocked_instructions_()
        self._right_paren_()

    @graken()
    def _min_freq_(self):
        self._real_()

    @graken()
    def _max_freq_(self):
        self._real_()

    @graken()
    def _clocked_instructions_(self):

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._clocked_instruction_()
        self._gather(block0, sep0)

    @graken()
    def _clocked_instruction_(self):
        with self._choice():
            with self._option():
                self._token('RUNBIST')
            with self._option():
                self._token('INTEST')
            with self._option():
                self._token('INIT_SETUP')
            with self._option():
                self._token('INIT_SETUP_CLAMP')
            with self._option():
                self._token('INIT_RUN')
            with self._option():
                self._token('ECIDCODE')
            with self._option():
                self._token('IC_RESET')
            with self._option():
                self._vhdl_identifier_()
            self._error('expecting one of: ECIDCODE IC_RESET INIT_RUN INIT_SETUP INIT_SETUP_CLAMP INTEST RUNBIST')

    @graken()
    def _register_mnemonics_description_(self):
        self._token('attribute')
        self._token('REGISTER_MNEMONICS')
        self._token('of')
        self._target_()
        self._token('is')
        self._register_mnemonics_string_()
        self._semicolon_()

    @graken()
    def _target_(self):
        with self._choice():
            with self._option():
                self._entity_target_()
            with self._option():
                self._package_target_()
            self._error('no available options')

    @graken()
    def _entity_target_(self):
        self._component_name_()
        self._colon_()
        self._token('entity')

    @graken()
    def _package_target_(self):
        self._user_package_name_()
        self._colon_()
        self._token('package')

    @graken()
    def _register_mnemonics_string_(self):

        def sep0():
            self._token('&')

        def block0():
            self._quote_()

            def sep1():
                with self._group():
                    self._comma_()

            def block1():
                with self._optional():
                    self._mnemonic_definition_()
            self._gather(block1, sep1)
            self._quote_()
        self._gather(block0, sep0)

    @graken()
    def _mnemonic_definition_(self):
        self._mnemonic_group_name_()
        self._left_paren_()
        self._mnemonic_list_()
        self._right_paren_()

    @graken()
    def _mnemonic_group_name_(self):
        self._vhdl_identifier_()

    @graken()
    def _mnemonic_list_(self):

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._mnemonic_assignment_()
        self._gather(block0, sep0)

    @graken()
    def _mnemonic_assignment_(self):
        self._mnemonic_identifier_()
        self._left_paren_()
        self._pattern_specification_()
        self._right_paren_()
        with self._optional():
            self._information_tag_()

    @graken()
    def _pattern_specification_(self):
        with self._choice():
            with self._option():
                self._binary_pattern_()
            with self._option():
                self._hex_pattern_()
            with self._option():
                self._decimal_pattern_()
            with self._option():
                self._token('others')
            self._error('expecting one of: others')

    @graken()
    def _register_fields_description_(self):
        self._token('attribute')
        self._token('REGISTER_FIELDS')
        self._token('of')
        self._target_()
        self._token('is')
        self._register_fields_string_()
        self._semicolon_()

    @graken()
    def _register_fields_string_(self):

        def sep0():
            self._token('&')

        def block0():
            self._quote_()

            def sep1():
                with self._group():
                    self._comma_()

            def block1():
                with self._optional():
                    self._register_field_list_()
            self._gather(block1, sep1)
            self._quote_()
        self._gather(block0, sep0)

    @graken()
    def _register_field_list_(self):
        self._reg_or_seg_name_()
        self._left_bracket_()
        self._reg_or_seg_length_()
        self._right_bracket_()
        self._left_paren_()
        self._register_fields_()
        self._right_paren_()

    @graken()
    def _reg_or_seg_name_(self):
        with self._choice():
            with self._option():
                self._tdr_()
            with self._option():
                self._segment_name_()
            self._error('no available options')

    @graken()
    def _tdr_(self):
        with self._choice():
            with self._option():
                self._token('BOUNDARY')
            with self._option():
                self._token('BYPASS')
            with self._option():
                self._token('DEVICE_ID')
            with self._option():
                self._token('TMP_STATUS')
            with self._option():
                self._token('ECID')
            with self._option():
                self._token('INIT_DATA')
            with self._option():
                self._token('INIT_STATUS')
            with self._option():
                self._token('RESET_SELECT')
            with self._option():
                self._design_specific_tdr_name_()
            self._error('expecting one of: BOUNDARY BYPASS DEVICE_ID ECID INIT_DATA INIT_STATUS RESET_SELECT TMP_STATUS')

    @graken()
    def _segment_name_(self):
        self._vhdl_identifier_()

    @graken()
    def _design_specific_tdr_name_(self):
        self._vhdl_identifier_()

    @graken()
    def _reg_or_seg_length_(self):
        self._integer_()

    @graken()
    def _register_fields_(self):

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._left_paren_()
                self._register_field_element_()
                self._right_paren_()
        self._gather(block0, sep0)

    @graken()
    def _register_field_element_(self):
        with self._choice():
            with self._option():
                self._register_field_()
            with self._option():
                self._prefix_statement_()
            self._error('no available options')

    @graken()
    def _register_field_(self):
        self._extended_field_name_()
        self._field_length_()
        self._token('is')
        self._bit_list_and_options_()

    @graken()
    def _extended_field_name_(self):
        self._prefix_string_()
        self._field_name_()

    @graken()
    def _prefix_string_(self):

        def block0():
            self._prefix_identifier_()
            self._period_()
        self._closure(block0)

    @graken()
    def _field_name_(self):
        self._vhdl_identifier_()

    @graken()
    def _field_length_(self):
        self._left_bracket_()
        self._integer_()
        self._right_bracket_()

    @graken()
    def _bit_list_and_options_(self):
        self._bit_list_()

        def block0():
            self._field_options_()
        self._closure(block0)

    @graken()
    def _field_options_(self):
        with self._choice():
            with self._option():
                self._type_assignment_()
            with self._option():
                self._value_assignment_()
            with self._option():
                self._reset_assignment_()
            self._error('no available options')

    @graken()
    def _bit_list_(self):
        self._left_paren_()
        with self._optional():

            def sep0():
                with self._group():
                    self._comma_()

            def block0():
                with self._optional():
                    self._bit_field_()
            self._gather(block0, sep0)
        self._right_paren_()

    @graken()
    def _bit_field_(self):
        with self._choice():
            with self._option():
                self._range_()
            with self._option():
                self._integer_()
            self._error('no available options')

    @graken()
    def _prefix_statement_(self):
        self._token('PREFIX')
        self._integer_()
        self._prefix_name_()

    @graken()
    def _prefix_name_(self):
        with self._choice():
            with self._option():
                self._prefix_identifier_()
            with self._option():
                self._minus_sign_()
            self._error('no available options')

    @graken()
    def _value_assignment_(self):
        self._value_keyword_()
        self._left_paren_()
        self._assignment_()
        self._right_paren_()

    @graken()
    def _value_keyword_(self):
        with self._choice():
            with self._option():
                self._token('CAPTURES')
            with self._option():
                self._token('DEFAULT')
            with self._option():
                self._token('SAFE')
            with self._option():
                self._token('RESETVAL')
            with self._option():
                self._user_extension_()
            self._error('expecting one of: CAPTURES DEFAULT RESETVAL SAFE')

    @graken()
    def _user_extension_(self):
        self._token('USER')
        self._colon_()
        self._user_keyword_()

    @graken()
    def _user_keyword_(self):
        self._vhdl_identifier_()

    @graken()
    def _assignment_(self):
        with self._choice():
            with self._option():
                self._assignment_value_()
            with self._option():
                self._asterisk_()
            with self._option():
                self._minus_sign_()
            self._error('no available options')

    @graken()
    def _assignment_value_(self):
        with self._choice():
            with self._option():
                self._binary_pattern_()
            with self._option():
                self._hex_pattern_()
            with self._option():
                self._decimal_pattern_()
            with self._option():
                self._mnemonic_association_()
            self._error('no available options')

    @graken()
    def _mnemonic_association_(self):
        with self._optional():
            self._token('PACKAGE')
            self._package_hierarchy_()
            self._colon_()
        self._mnemonic_group_name_()
        self._left_paren_()
        self._mnemonic_default_()
        self._right_paren_()

    @graken()
    def _mnemonic_default_(self):
        with self._choice():
            with self._option():
                self._mnemonic_identifier_()
            with self._option():
                self._asterisk_()
            with self._option():
                self._minus_sign_()
            self._error('no available options')

    @graken()
    def _type_assignment_(self):
        with self._choice():
            with self._option():
                self._token('NOPI')
            with self._option():
                self._token('NOPO')
            with self._option():
                self._token('NOUPD')
            with self._option():
                self._token('MON')
            with self._option():
                self._token('PULSE0')
            with self._option():
                self._token('PULSE1')
            with self._option():
                self._token('DELAYPO')
            with self._option():
                self._token('NORETAIN')
            with self._option():
                self._token('SHARED')
            with self._option():
                self._user_extension_()
            self._error('expecting one of: DELAYPO MON NOPI NOPO NORETAIN NOUPD PULSE0 PULSE1 SHARED')

    @graken()
    def _reset_assignment_(self):
        with self._choice():
            with self._option():
                self._token('PORRESET')
            with self._option():
                self._token('TRSTRESET')
            with self._option():
                self._token('TAPRESET')
            with self._option():
                self._token('CHRESET')
            with self._option():
                self._token('DOMPOR')
            with self._option():
                self._token('HIERRESET')
            with self._option():
                self._local_reset_assignment_()
            self._error('expecting one of: CHRESET DOMPOR HIERRESET PORRESET TAPRESET TRSTRESET')

    @graken()
    def _local_reset_assignment_(self):
        self._reset_type_()
        self._left_paren_()
        self._reset_ident_()
        self._right_paren_()

    @graken()
    def _reset_type_(self):
        with self._choice():
            with self._option():
                self._token('RESETOUT')
            with self._option():
                self._token('RESETIN')
            self._error('expecting one of: RESETIN RESETOUT')

    @graken()
    def _reset_ident_(self):
        self._vhdl_identifier_()

    @graken()
    def _domain_assignment_(self):
        self._association_type_()
        self._left_paren_()
        self._association_name_()
        self._right_paren_()

    @graken()
    def _association_type_(self):
        with self._choice():
            with self._option():
                self._token('DOMAIN')
            with self._option():
                self._token('DOMAIN_EXTERNAL')
            with self._option():
                self._token('SEGMENT')
            self._error('expecting one of: DOMAIN DOMAIN_EXTERNAL SEGMENT')

    @graken()
    def _association_name_(self):
        self._vhdl_identifier_()

    @graken()
    def _register_assembly_description_(self):
        self._token('attribute')
        self._token('REGISTER_ASSEMBLY')
        self._token('of')
        self._target_()
        self._token('is')
        self._register_assembly_string_()
        self._semicolon_()

    @graken()
    def _register_assembly_string_(self):

        def sep0():
            self._token('&')

        def block0():
            self._quote_()

            def sep1():
                with self._group():
                    self._comma_()

            def block1():
                with self._optional():
                    self._register_assembly_list_()
            self._gather(block1, sep1)
            self._quote_()
        self._gather(block0, sep0)

    @graken()
    def _register_assembly_list_(self):
        self._reg_or_seg_name_()
        self._left_paren_()
        self._register_assembly_elements_()
        self._right_paren_()

    @graken()
    def _register_assembly_elements_(self):

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._left_paren_()
                self._register_element_()
                self._right_paren_()
        self._gather(block0, sep0)

    @graken()
    def _register_element_(self):
        with self._choice():
            with self._option():
                self._instance_and_options_()
            with self._option():
                self._field_and_options_()
            with self._option():
                self._instance_reference_()
            with self._option():
                self._selected_segment_element_()
            with self._option():
                self._boundary_instance_()
            with self._option():
                self._using_statement_()
            self._error('no available options')

    @graken()
    def _instance_and_options_(self):
        self._instance_definition_()

        def block0():
            self._field_assignments_()
        self._closure(block0)

    @graken()
    def _instance_definition_(self):
        self._instance_ident_()
        self._token('is')
        with self._optional():
            self._token('PACKAGE')
            self._package_hierarchy_()
            self._colon_()
        self._reg_or_seg_name_()

    @graken()
    def _instance_ident_(self):
        with self._choice():
            with self._option():
                self._segment_ident_()
            with self._option():
                self._array_ident_()
            self._error('no available options')

    @graken()
    def _segment_ident_(self):
        self._vhdl_identifier_()

    @graken()
    def _array_ident_(self):
        self._token('ARRAY')
        self._array_segment_ident_()
        self._left_paren_()
        self._range_()
        self._right_paren_()

    @graken()
    def _array_segment_ident_(self):
        self._vhdl_identifier_()

    @graken()
    def _field_assignments_(self):
        with self._choice():
            with self._option():
                self._field_value_assignment_()
            with self._option():
                self._field_reset_assignment_()
            with self._option():
                self._field_domain_assignment_()
            with self._option():
                self._field_selection_assignment_()
            self._error('no available options')

    @graken()
    def _field_value_assignment_(self):
        with self._optional():
            self._field_ident_()
            self._colon_()
        self._value_assignment_()

    @graken()
    def _field_reset_assignment_(self):
        with self._optional():
            self._field_ident_()
            self._colon_()
        self._reset_assignment_()

    @graken()
    def _field_domain_assignment_(self):
        with self._optional():
            self._field_ident_()
            self._colon_()
        self._domain_assignment_()

    @graken()
    def _field_ident_(self):

        def block0():
            self._instance_name_()
            self._period_()
        self._closure(block0)
        self._field_name_()

    @graken()
    def _instance_name_(self):
        with self._choice():
            with self._option():
                self._segment_ident_()
            with self._option():
                self._array_instances_()
            self._error('no available options')

    @graken()
    def _array_instances_(self):
        self._array_segment_ident_()
        self._bit_list_()

    @graken()
    def _field_and_options_(self):
        self._field_name_()
        self._field_length_()

        def block0():
            self._field_options_()
        self._closure(block0)

    @graken()
    def _instance_reference_(self):
        with self._choice():
            with self._option():
                self._segment_ident_()
            with self._option():
                self._array_instance_()
            self._error('no available options')

    @graken()
    def _array_instance_(self):
        self._array_segment_ident_()
        self._left_paren_()
        self._index_()
        self._right_paren_()

    @graken()
    def _index_(self):
        self._integer_()

    @graken()
    def _selected_segment_element_(self):
        self._token('SELECTMUX')

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._left_paren_()
                self._selectable_segment_()
                self._right_paren_()
        self._gather(block0, sep0)
        self._field_selection_assignment_()

    @graken()
    def _selectable_segment_(self):
        with self._choice():
            with self._option():
                self._instance_and_options_()
            with self._option():
                self._instance_reference_()
            self._error('no available options')

    @graken()
    def _field_selection_assignment_(self):
        self._selection_field_()
        self._selection_values_()
        with self._optional():
            self._broadcast_field_()
            self._broadcast_values_()

    @graken()
    def _selection_field_(self):
        self._token('SELECTFIELD')
        self._left_paren_()
        self._field_reference_()
        self._right_paren_()

    @graken()
    def _field_reference_(self):

        def block0():
            self._instance_reference_()
            self._period_()
        self._closure(block0)
        self._field_name_()

    @graken()
    def _selection_values_(self):
        self._token('SELECTVALUES')
        self._left_paren_()
        self._segment_selection_()

        def block0():
            self._segment_selection_()
        self._closure(block0)
        self._right_paren_()

    @graken()
    def _segment_selection_(self):
        self._left_paren_()
        self._instance_reference_()
        self._colon_()

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._field_value_()
        self._gather(block0, sep0)
        self._right_paren_()

    @graken()
    def _field_value_(self):
        with self._choice():
            with self._option():
                self._mnemonic_identifier_()
            with self._option():
                self._binary_pattern_()
            with self._option():
                self._hex_pattern_()
            with self._option():
                self._decimal_pattern_()
            self._error('no available options')

    @graken()
    def _broadcast_field_(self):
        self._token('BROADCASTFIELD')
        self._left_paren_()
        self._field_reference_()
        self._right_paren_()

    @graken()
    def _broadcast_values_(self):
        self._token('BROADCASTVALUES')
        self._left_paren_()
        self._broadcast_selection_()

        def block0():
            self._broadcast_selection_()
        self._closure(block0)
        self._right_paren_()

    @graken()
    def _broadcast_selection_(self):
        self._left_paren_()

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._instance_reference_()
        self._gather(block0, sep0)
        self._colon_()

        def sep1():
            with self._group():
                self._comma_()

        def block1():
            with self._optional():
                self._field_value_()
        self._gather(block1, sep1)
        self._right_paren_()

    @graken()
    def _boundary_instance_(self):
        self._segment_ident_()
        self._token('is')
        with self._optional():
            self._token('PACKAGE')
            self._package_hierarchy_()
            self._colon_()
        self._boundary_segment_name_()

    @graken()
    def _using_statement_(self):
        self._token('USING')
        self._package_prefix_()

    @graken()
    def _package_prefix_(self):
        with self._choice():
            with self._option():
                self._package_hierarchy_()
            with self._option():
                self._minus_sign_()
            self._error('no available options')

    @graken()
    def _package_hierarchy_(self):
        self._user_package_name_()

        def block0():
            self._period_()
            self._user_package_name_()
        self._closure(block0)

    @graken()
    def _register_constraints_description_(self):
        self._token('attribute')
        self._token('REGISTER_CONSTRAINTS')
        self._token('of')
        self._target_()
        self._token('is')
        self._constraints_string_()
        self._semicolon_()

    @graken()
    def _constraints_string_(self):

        def sep0():
            self._token('&')

        def block0():
            self._quote_()

            def sep1():
                with self._group():
                    self._comma_()

            def block1():
                with self._optional():
                    self._constraints_list_()
            self._gather(block1, sep1)
            self._quote_()
        self._gather(block0, sep0)

    @graken()
    def _constraints_list_(self):
        self._constraint_domain_()
        self._left_paren_()
        self._constraint_checks_()
        self._right_paren_()

    @graken()
    def _constraint_domain_(self):
        with self._choice():
            with self._option():
                self._reg_or_seg_name_()
            with self._option():
                self._token('entity')
            with self._option():
                self._token('package')
            self._error('expecting one of: entity package')

    @graken()
    def _constraint_checks_(self):

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._left_paren_()
                self._check_expression_()
                self._right_paren_()
                self._constraint_severity_()
                self._information_tag_()
        self._gather(block0, sep0)

    @graken()
    def _constraint_severity_(self):
        with self._choice():
            with self._option():
                self._token('error')
            with self._option():
                self._token('warning')
            with self._option():
                self._token('info')
            self._error('expecting one of: error info warning')

    @graken()
    def _check_expression_(self):
        with self._choice():
            with self._option():
                self._short_expression_()
            with self._option():
                self._binary_expr_()
            self._error('no available options')

    @graken()
    def _short_expression_(self):
        with self._choice():
            with self._option():
                self._nested_expr_()
            with self._option():
                self._unary_expr_()
            with self._option():
                self._field_reference_()
            with self._option():
                self._oper_val_()
            self._error('no available options')

    @graken()
    def _nested_expr_(self):
        self._left_paren_()
        self._check_expression_()
        self._right_paren_()

    @graken()
    def _unary_expr_(self):
        with self._choice():
            with self._option():
                self._logical_inv_expr_()
            with self._option():
                self._bit_wise_inv_expr_()
            with self._option():
                self._one_hot_expr_()
            self._error('no available options')

    @graken()
    def _logical_inv_expr_(self):
        self._logical_inversion_()
        self._short_expression_()

    @graken()
    def _bit_wise_inv_expr_(self):
        self._bit_wise_inversion_()
        self._short_expression_()

    @graken()
    def _one_hot_expr_(self):
        self._one_hot_()
        self._nested_expr_()

    @graken()
    def _binary_expr_(self):
        self._short_expression_()
        self._binary_operator_()
        self._check_expression_()

    @graken()
    def _binary_operator_(self):
        with self._choice():
            with self._option():
                self._exponentiation_()
            with self._option():
                self._multiplication_()
            with self._option():
                self._division_()
            with self._option():
                self._remainder_()
            with self._option():
                self._addition_()
            with self._option():
                self._subtraction_()
            with self._option():
                self._right_shift_()
            with self._option():
                self._left_shift_()
            with self._option():
                self._less_than_()
            with self._option():
                self._greater_than_()
            with self._option():
                self._less_than_or_equal_()
            with self._option():
                self._greater_than_or_equal_()
            with self._option():
                self._equals_()
            with self._option():
                self._not_equals_()
            with self._option():
                self._bit_wise_and_()
            with self._option():
                self._bit_wise_xor_()
            with self._option():
                self._bit_wise_or_()
            with self._option():
                self._logical_and_()
            with self._option():
                self._logical_or_()
            self._error('no available options')

    @graken()
    def _oper_val_(self):
        with self._choice():
            with self._option():
                self._mnemonic_pattern_()
            with self._option():
                self._binary_pattern_()
            with self._option():
                self._hex_pattern_()
            with self._option():
                self._decimal_pattern_()
            self._error('no available options')

    @graken()
    def _mnemonic_pattern_(self):
        with self._optional():
            with self._optional():
                self._token('PACKAGE')
                self._package_hierarchy_()
                self._colon_()
            self._mnemonic_group_name_()
        self._left_brace_()
        self._mnemonic_identifier_()
        self._right_brace_()

    @graken()
    def _logical_inversion_(self):
        self._token('!')

    @graken()
    def _bit_wise_inversion_(self):
        self._token('~')

    @graken()
    def _one_hot_(self):
        self._token('one_hot')

    @graken()
    def _exponentiation_(self):
        self._token('**')

    @graken()
    def _multiplication_(self):
        self._token('*')

    @graken()
    def _division_(self):
        self._token('/')

    @graken()
    def _remainder_(self):
        self._token('%')

    @graken()
    def _addition_(self):
        self._token('+')

    @graken()
    def _subtraction_(self):
        self._token('-')

    @graken()
    def _left_shift_(self):
        self._token('<<')

    @graken()
    def _right_shift_(self):
        self._token('>>')

    @graken()
    def _less_than_(self):
        self._token('<')

    @graken()
    def _greater_than_(self):
        self._token('>')

    @graken()
    def _less_than_or_equal_(self):
        self._token('<=')

    @graken()
    def _greater_than_or_equal_(self):
        self._token('>=')

    @graken()
    def _equals_(self):
        self._token('==')

    @graken()
    def _not_equals_(self):
        self._token('!=')

    @graken()
    def _bit_wise_and_(self):
        self._token('&')

    @graken()
    def _bit_wise_xor_(self):
        self._token('^')

    @graken()
    def _bit_wise_or_(self):
        self._token('|')

    @graken()
    def _logical_and_(self):
        self._token('&&')

    @graken()
    def _logical_or_(self):
        self._token('||')

    @graken()
    def _register_association_description_(self):
        self._token('attribute')
        self._token('REGISTER_ASSOCIATION')
        self._token('of')
        self._target_()
        self._token('is')
        self._register_association_string_()
        self._semicolon_()

    @graken()
    def _register_association_string_(self):

        def sep0():
            self._token('&')

        def block0():
            self._quote_()

            def sep1():
                with self._group():
                    self._comma_()

            def block1():
                with self._optional():
                    self._register_association_list_()
            self._gather(block1, sep1)
            self._quote_()
        self._gather(block0, sep0)

    @graken()
    def _register_association_list_(self):
        self._reg_field_or_instance_()
        self._colon_()

        def block0():
            self._association_list_()
        self._positive_closure(block0)

    @graken()
    def _reg_field_or_instance_(self):
        self._field_or_instance_name_()
        with self._optional():
            self._left_paren_()
            self._index_()
            self._right_paren_()

    @graken()
    def _field_or_instance_name_(self):
        with self._choice():
            with self._option():
                self._extended_field_name_()
            with self._option():
                self._segment_ident_()
            with self._option():
                self._array_segment_ident_()
            with self._option():
                self._tdr_()
            self._error('no available options')

    @graken()
    def _association_list_(self):
        with self._choice():
            with self._option():
                self._port_list_()
            with self._option():
                self._info_list_()
            with self._option():
                self._clock_list_()
            with self._option():
                self._user_list_()
            with self._option():
                self._unit_()
            self._error('no available options')

    @graken()
    def _port_list_(self):
        self._token('port')
        self._port_association_list_()

    @graken()
    def _port_association_list_(self):
        self._left_paren_()

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._port_id_()
        self._gather(block0, sep0)
        self._right_paren_()

    @graken()
    def _info_list_(self):
        self._token('info')
        self._left_paren_()

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._information_tag_()
        self._gather(block0, sep0)
        self._right_paren_()

    @graken()
    def _clock_list_(self):
        self._token('sysclock')
        self._left_paren_()

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._port_id_()
        self._gather(block0, sep0)
        self._right_paren_()

    @graken()
    def _user_list_(self):
        self._token('user')
        self._user_list_name_()
        self._left_paren_()
        self._single_or_multi_list_()
        self._right_paren_()

    @graken()
    def _user_list_name_(self):
        self._vhdl_identifier_()

    @graken()
    def _single_or_multi_list_(self):
        with self._choice():
            with self._option():
                self._single_word_user_list_()
            with self._option():
                self._multi_word_user_list_()
            self._error('no available options')

    @graken()
    def _single_word_user_list_(self):

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._vhdl_identifier_()
        self._gather(block0, sep0)

    @graken()
    def _multi_word_user_list_(self):

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._information_tag_()
        self._gather(block0, sep0)

    @graken()
    def _unit_(self):
        self._token('unit')
        self._left_paren_()
        self._unit_name_()
        self._unit_definition_()
        self._right_paren_()

    @graken()
    def _unit_definition_(self):
        self._left_brace_()
        self._unit_value_()
        with self._optional():
            self._unit_scale_()
        with self._optional():
            self._unit_link_()
        self._right_brace_()

    @graken()
    def _unit_name_(self):
        self._vhdl_identifier_()

    @graken()
    def _unit_value_(self):
        self._hex_pattern_()

    @graken()
    def _unit_scale_(self):
        self._real_()

    @graken()
    def _unit_link_(self):
        self._information_tag_()

    @graken()
    def _power_port_association_description_(self):
        self._token('attribute')
        self._token('POWER_PORT_ASSOCIATION')
        self._token('of')
        self._entity_target_()
        self._token('is')
        self._power_port_association_string_()
        self._semicolon_()

    @graken()
    def _power_port_association_string_(self):

        def sep0():
            self._token('&')

        def block0():
            self._quote_()

            def sep1():
                with self._group():
                    self._comma_()

            def block1():
                with self._optional():
                    self._power_port_association_list_()
            self._gather(block1, sep1)
            self._quote_()
        self._gather(block0, sep0)

    @graken()
    def _power_port_association_list_(self):
        self._power_port_id_()
        self._colon_()
        self._port_association_list_()

    @graken()
    def _power_port_id_(self):
        self._port_id_()

    @graken()
    def _bsdl_extensions_(self):
        with self._choice():
            with self._option():
                self._extension_declaration_()
                self.name_last_node('@')
            with self._option():
                self._extension_definition_()
                self.name_last_node('@')
            self._error('no available options')

    @graken()
    def _extension_declaration_(self):
        self._token('attribute')
        self._extension_name_()
        self.name_last_node('extension_name')
        self._colon_()
        self._token('BSDL_EXTENSION')
        self._semicolon_()
        self.ast._define(
            ['extension_name'],
            []
        )

    @graken()
    def _extension_definition_(self):
        self._token('attribute')
        self._extension_name_()
        self.name_last_node('extension_name')
        self._token('of')
        self._target_()
        self._token('is')
        self._extension_parameter_string_()
        self.name_last_node('extension_parameters')
        self._semicolon_()
        self.ast._define(
            ['extension_name', 'extension_parameters'],
            []
        )

    @graken()
    def _extension_name_(self):
        with self._choice():
            with self._option():
                self._entity_defined_name_()
            with self._option():
                self._bsdl_package_defined_name_()
            self._error('no available options')

    @graken()
    def _entity_defined_name_(self):
        self._vhdl_identifier_()

    @graken()
    def _bsdl_package_defined_name_(self):
        self._vhdl_identifier_()

    @graken()
    def _extension_parameter_string_(self):
        self._string_()

    @graken()
    def _design_warning_(self):
        self._token('attribute')
        self._token('DESIGN_WARNING')
        self._token('of')
        self._target_()
        self._token('is')
        self._string_()
        self.name_last_node('@')
        self._semicolon_()

    @graken()
    def _user_package_(self):
        self._user_package_stmt_()
        self._user_package_body_()

    @graken()
    def _user_package_stmt_(self):
        self._token('package')
        self._user_package_name_()
        self._token('is')
        self._standard_use_statement_()

        def block0():
            self._deferred_constant_()
        self._closure(block0)

        def block1():
            self._extension_declaration_()
        self._closure(block1)
        self._token('end')
        self._user_package_name_()
        self._semicolon_()

    @graken()
    def _deferred_constant_(self):
        self._token('constant')
        self._cell_name_()
        self._colon_()
        self._token('CELL_INFO')
        self._semicolon_()

    @graken()
    def _user_package_body_(self):
        self._token('package')
        self._token('body')
        self._user_package_name_()
        self._token('is')
        self._standard_use_statement_()

        def block0():
            self._use_statement_()
        self._closure(block0)

        def block1():
            self._cell_description_constant_()
        self._closure(block1)

        def block2():
            self._register_mnemonics_description_()
        self._closure(block2)

        def block3():
            self._register_fields_description_()
        self._closure(block3)

        def block4():
            self._register_assembly_description_()
        self._closure(block4)

        def block5():
            self._register_constraints_description_()
        self._closure(block5)

        def block6():
            self._register_association_description_()
        self._closure(block6)

        def block7():
            self._extension_definition_()
        self._closure(block7)
        with self._optional():
            self._design_warning_()
        self._token('end')
        self._user_package_name_()
        self._semicolon_()

    @graken()
    def _cell_description_constant_(self):
        self._token('constant')
        self._cell_name_()
        self._colon_()
        self._token('CELL_INFO')
        self._colon_equal_()
        self._left_paren_()
        self._capture_descriptor_list_()
        self._right_paren_()
        self._semicolon_()

    @graken()
    def _capture_descriptor_list_(self):

        def sep0():
            with self._group():
                self._comma_()

        def block0():
            with self._optional():
                self._capture_descriptor_()
        self._gather(block0, sep0)

    @graken()
    def _capture_descriptor_(self):
        self._left_paren_()
        self._cell_context_()
        self._comma_()
        self._capture_instruction_()
        self._comma_()
        self._data_source_()
        self._right_paren_()

    @graken()
    def _cell_context_(self):
        with self._choice():
            with self._option():
                self._token('INPUT')
            with self._option():
                self._token('OUTPUT2')
            with self._option():
                self._token('OUTPUT3')
            with self._option():
                self._token('INTERNAL')
            with self._option():
                self._token('CONTROL')
            with self._option():
                self._token('CONTROLR')
            with self._option():
                self._token('CLOCK')
            with self._option():
                self._token('BIDIR_IN')
            with self._option():
                self._token('BIDIR_OUT')
            with self._option():
                self._token('OBSERVE_ONLY')
            self._error('expecting one of: BIDIR_IN BIDIR_OUT CLOCK CONTROL CONTROLR INPUT INTERNAL OBSERVE_ONLY OUTPUT2 OUTPUT3')

    @graken()
    def _capture_instruction_(self):
        with self._choice():
            with self._option():
                self._token('EXTEST')
            with self._option():
                self._token('SAMPLE')
            with self._option():
                self._token('INTEST')
            self._error('expecting one of: EXTEST INTEST SAMPLE')

    @graken()
    def _data_source_(self):
        with self._choice():
            with self._option():
                self._token('PI')
            with self._option():
                self._token('PO')
            with self._option():
                self._token('CAP')
            with self._option():
                self._token('UPD')
            with self._option():
                self._token('ZERO')
            with self._option():
                self._token('ONE')
            with self._option():
                self._token('X')
            self._error('expecting one of: CAP ONE PI PO UPD X ZERO')

    @graken()
    def _asterisk_(self):
        self._token('*')

    @graken()
    def _colon_(self):
        self._token(':')

    @graken()
    def _colon_equal_(self):
        self._token(':=')

    @graken()
    def _comma_(self):
        self._token(',')

    @graken()
    def _left_brace_(self):
        self._token('{')

    @graken()
    def _left_bracket_(self):
        self._token('[')

    @graken()
    def _left_paren_(self):
        self._token('(')

    @graken()
    def _minus_sign_(self):
        self._token('-')

    @graken()
    def _period_(self):
        self._token('.')

    @graken()
    def _quote_(self):
        self._token('"')

    @graken()
    def _right_brace_(self):
        self._token('}')

    @graken()
    def _right_bracket_(self):
        self._token(']')

    @graken()
    def _right_paren_(self):
        self._token(')')

    @graken()
    def _semicolon_(self):
        self._token(';')


class bsdlSemantics(object):
    def letters(self, ast):
        return ast

    def digit(self, ast):
        return ast

    def vhdl_identifier(self, ast):
        return ast

    def mnemonic_identifier(self, ast):
        return ast

    def prefix_identifier(self, ast):
        return ast

    def integer(self, ast):
        return ast

    def real(self, ast):
        return ast

    def pattern(self, ast):
        return ast

    def thirty_two_bit_pattern(self, ast):
        return ast

    def binary_pattern(self, ast):
        return ast

    def hex_pattern(self, ast):
        return ast

    def decimal_pattern(self, ast):
        return ast

    def string(self, ast):
        return ast

    def information_tag(self, ast):
        return ast

    def port_id(self, ast):
        return ast

    def port_name(self, ast):
        return ast

    def subscripted_port_name(self, ast):
        return ast

    def subscript(self, ast):
        return ast

    def instruction_name(self, ast):
        return ast

    def bsdl_description(self, ast):
        return ast

    def component_name(self, ast):
        return ast

    def generic_parameter(self, ast):
        return ast

    def generic_default(self, ast):
        return ast

    def generic_no_default(self, ast):
        return ast

    def default_device_package_type(self, ast):
        return ast

    def logical_port_description(self, ast):
        return ast

    def pin_spec(self, ast):
        return ast

    def identifier_list(self, ast):
        return ast

    def pin_type(self, ast):
        return ast

    def port_dimension(self, ast):
        return ast

    def bit_vector_spec(self, ast):
        return ast

    def range(self, ast):
        return ast

    def up_range(self, ast):
        return ast

    def down_range(self, ast):
        return ast

    def integer1(self, ast):
        return ast

    def integer2(self, ast):
        return ast

    def standard_use_statement(self, ast):
        return ast

    def standard_package_name(self, ast):
        return ast

    def use_statement(self, ast):
        return ast

    def user_package_name(self, ast):
        return ast

    def component_conformance_statement(self, ast):
        return ast

    def conformance_string(self, ast):
        return ast

    def conformance_identification(self, ast):
        return ast

    def device_package_pin_mappings(self, ast):
        return ast

    def pin_map_statement(self, ast):
        return ast

    def pin_mappings(self, ast):
        return ast

    def pin_mapping(self, ast):
        return ast

    def pin_mapping_name(self, ast):
        return ast

    def map_string(self, ast):
        return ast

    def port_map(self, ast):
        return ast

    def port(self, ast):
        return ast

    def pin_or_list(self, ast):
        return ast

    def pin_list(self, ast):
        return ast

    def pin_desc(self, ast):
        return ast

    def pin_id(self, ast):
        return ast

    def grouped_port_identification(self, ast):
        return ast

    def group_table_string(self, ast):
        return ast

    def group_table(self, ast):
        return ast

    def twin_group_entry(self, ast):
        return ast

    def twin_group_type(self, ast):
        return ast

    def twin_group_list(self, ast):
        return ast

    def twin_group(self, ast):
        return ast

    def representative_port(self, ast):
        return ast

    def associated_port(self, ast):
        return ast

    def scan_port_identification(self, ast):
        return ast

    def scan_port_stmt(self, ast):
        return ast

    def tck_stmt(self, ast):
        return ast

    def tdi_stmt(self, ast):
        return ast

    def tms_stmt(self, ast):
        return ast

    def tdo_stmt(self, ast):
        return ast

    def trst_stmt(self, ast):
        return ast

    def clock_record(self, ast):
        return ast

    def halt_state_value(self, ast):
        return ast

    def compliance_enable_description(self, ast):
        return ast

    def compliance_pattern_string(self, ast):
        return ast

    def compliance_port_list(self, ast):
        return ast

    def pattern_list(self, ast):
        return ast

    def instruction_register_description(self, ast):
        return ast

    def instruction_length_stmt(self, ast):
        return ast

    def instruction_opcode_stmt(self, ast):
        return ast

    def instruction_capture_stmt(self, ast):
        return ast

    def instruction_private_stmt(self, ast):
        return ast

    def opcode_table_string(self, ast):
        return ast

    def opcode_description(self, ast):
        return ast

    def opcode_list(self, ast):
        return ast

    def opcode(self, ast):
        return ast

    def pattern_list_string(self, ast):
        return ast

    def instruction_list_string(self, ast):
        return ast

    def instruction_list(self, ast):
        return ast

    def optional_register_description(self, ast):
        return ast

    def optional_register_stmt(self, ast):
        return ast

    def idcode_statement(self, ast):
        return ast

    def usercode_statement(self, ast):
        return ast

    def thirty_two_bit_pattern_list(self, ast):
        return ast

    def register_access_description(self, ast):
        return ast

    def register_access_string(self, ast):
        return ast

    def register_association(self, ast):
        return ast

    def instruction_capture_list(self, ast):
        return ast

    def instruction_capture(self, ast):
        return ast

    def register(self, ast):
        return ast

    def std_fixed_register(self, ast):
        return ast

    def std_var_register(self, ast):
        return ast

    def std_var_reg_name(self, ast):
        return ast

    def design_specific_register(self, ast):
        return ast

    def reg_length(self, ast):
        return ast

    def boundary_scan_register_description(self, ast):
        return ast

    def fixed_boundary_stmts(self, ast):
        return ast

    def segment_boundary_stmts(self, ast):
        return ast

    def boundary_length_stmt(self, ast):
        return ast

    def register_length(self, ast):
        return ast

    def boundary_register_stmt(self, ast):
        return ast

    def cell_table_string(self, ast):
        return ast

    def assembled_boundary_length_stmt(self, ast):
        return ast

    def reset_length(self, ast):
        return ast

    def boundary_register_segments(self, ast):
        return ast

    def boundary_register_segment(self, ast):
        return ast

    def boundary_segment_string(self, ast):
        return ast

    def boundary_segment_list(self, ast):
        return ast

    def boundary_segment_name(self, ast):
        return ast

    def boundary_segment_length(self, ast):
        return ast

    def cell_table(self, ast):
        return ast

    def cell_entry(self, ast):
        return ast

    def cell_number(self, ast):
        return ast

    def cell_info(self, ast):
        return ast

    def cell_spec(self, ast):
        return ast

    def cell_name(self, ast):
        return ast

    def port_id_or_null(self, ast):
        return ast

    def function(self, ast):
        return ast

    def safe_bit(self, ast):
        return ast

    def input_or_disable_spec(self, ast):
        return ast

    def input_spec(self, ast):
        return ast

    def disable_spec(self, ast):
        return ast

    def ccell(self, ast):
        return ast

    def disable_value(self, ast):
        return ast

    def disable_result(self, ast):
        return ast

    def runbist_description(self, ast):
        return ast

    def runbist_spec(self, ast):
        return ast

    def wait_spec(self, ast):
        return ast

    def duration_spec(self, ast):
        return ast

    def time_and_clocks(self, ast):
        return ast

    def clock_cycles_list(self, ast):
        return ast

    def time(self, ast):
        return ast

    def clock_cycles(self, ast):
        return ast

    def pin_state(self, ast):
        return ast

    def condition(self, ast):
        return ast

    def signature_spec(self, ast):
        return ast

    def det_pattern(self, ast):
        return ast

    def bit(self, ast):
        return ast

    def intest_description(self, ast):
        return ast

    def intest_spec(self, ast):
        return ast

    def system_clock_description(self, ast):
        return ast

    def system_clock_description_string(self, ast):
        return ast

    def system_clock_requirement(self, ast):
        return ast

    def min_freq(self, ast):
        return ast

    def max_freq(self, ast):
        return ast

    def clocked_instructions(self, ast):
        return ast

    def clocked_instruction(self, ast):
        return ast

    def register_mnemonics_description(self, ast):
        return ast

    def target(self, ast):
        return ast

    def entity_target(self, ast):
        return ast

    def package_target(self, ast):
        return ast

    def register_mnemonics_string(self, ast):
        return ast

    def mnemonic_definition(self, ast):
        return ast

    def mnemonic_group_name(self, ast):
        return ast

    def mnemonic_list(self, ast):
        return ast

    def mnemonic_assignment(self, ast):
        return ast

    def pattern_specification(self, ast):
        return ast

    def register_fields_description(self, ast):
        return ast

    def register_fields_string(self, ast):
        return ast

    def register_field_list(self, ast):
        return ast

    def reg_or_seg_name(self, ast):
        return ast

    def tdr(self, ast):
        return ast

    def segment_name(self, ast):
        return ast

    def design_specific_tdr_name(self, ast):
        return ast

    def reg_or_seg_length(self, ast):
        return ast

    def register_fields(self, ast):
        return ast

    def register_field_element(self, ast):
        return ast

    def register_field(self, ast):
        return ast

    def extended_field_name(self, ast):
        return ast

    def prefix_string(self, ast):
        return ast

    def field_name(self, ast):
        return ast

    def field_length(self, ast):
        return ast

    def bit_list_and_options(self, ast):
        return ast

    def field_options(self, ast):
        return ast

    def bit_list(self, ast):
        return ast

    def bit_field(self, ast):
        return ast

    def prefix_statement(self, ast):
        return ast

    def prefix_name(self, ast):
        return ast

    def value_assignment(self, ast):
        return ast

    def value_keyword(self, ast):
        return ast

    def user_extension(self, ast):
        return ast

    def user_keyword(self, ast):
        return ast

    def assignment(self, ast):
        return ast

    def assignment_value(self, ast):
        return ast

    def mnemonic_association(self, ast):
        return ast

    def mnemonic_default(self, ast):
        return ast

    def type_assignment(self, ast):
        return ast

    def reset_assignment(self, ast):
        return ast

    def local_reset_assignment(self, ast):
        return ast

    def reset_type(self, ast):
        return ast

    def reset_ident(self, ast):
        return ast

    def domain_assignment(self, ast):
        return ast

    def association_type(self, ast):
        return ast

    def association_name(self, ast):
        return ast

    def register_assembly_description(self, ast):
        return ast

    def register_assembly_string(self, ast):
        return ast

    def register_assembly_list(self, ast):
        return ast

    def register_assembly_elements(self, ast):
        return ast

    def register_element(self, ast):
        return ast

    def instance_and_options(self, ast):
        return ast

    def instance_definition(self, ast):
        return ast

    def instance_ident(self, ast):
        return ast

    def segment_ident(self, ast):
        return ast

    def array_ident(self, ast):
        return ast

    def array_segment_ident(self, ast):
        return ast

    def field_assignments(self, ast):
        return ast

    def field_value_assignment(self, ast):
        return ast

    def field_reset_assignment(self, ast):
        return ast

    def field_domain_assignment(self, ast):
        return ast

    def field_ident(self, ast):
        return ast

    def instance_name(self, ast):
        return ast

    def array_instances(self, ast):
        return ast

    def field_and_options(self, ast):
        return ast

    def instance_reference(self, ast):
        return ast

    def array_instance(self, ast):
        return ast

    def index(self, ast):
        return ast

    def selected_segment_element(self, ast):
        return ast

    def selectable_segment(self, ast):
        return ast

    def field_selection_assignment(self, ast):
        return ast

    def selection_field(self, ast):
        return ast

    def field_reference(self, ast):
        return ast

    def selection_values(self, ast):
        return ast

    def segment_selection(self, ast):
        return ast

    def field_value(self, ast):
        return ast

    def broadcast_field(self, ast):
        return ast

    def broadcast_values(self, ast):
        return ast

    def broadcast_selection(self, ast):
        return ast

    def boundary_instance(self, ast):
        return ast

    def using_statement(self, ast):
        return ast

    def package_prefix(self, ast):
        return ast

    def package_hierarchy(self, ast):
        return ast

    def register_constraints_description(self, ast):
        return ast

    def constraints_string(self, ast):
        return ast

    def constraints_list(self, ast):
        return ast

    def constraint_domain(self, ast):
        return ast

    def constraint_checks(self, ast):
        return ast

    def constraint_severity(self, ast):
        return ast

    def check_expression(self, ast):
        return ast

    def short_expression(self, ast):
        return ast

    def nested_expr(self, ast):
        return ast

    def unary_expr(self, ast):
        return ast

    def logical_inv_expr(self, ast):
        return ast

    def bit_wise_inv_expr(self, ast):
        return ast

    def one_hot_expr(self, ast):
        return ast

    def binary_expr(self, ast):
        return ast

    def binary_operator(self, ast):
        return ast

    def oper_val(self, ast):
        return ast

    def mnemonic_pattern(self, ast):
        return ast

    def logical_inversion(self, ast):
        return ast

    def bit_wise_inversion(self, ast):
        return ast

    def one_hot(self, ast):
        return ast

    def exponentiation(self, ast):
        return ast

    def multiplication(self, ast):
        return ast

    def division(self, ast):
        return ast

    def remainder(self, ast):
        return ast

    def addition(self, ast):
        return ast

    def subtraction(self, ast):
        return ast

    def left_shift(self, ast):
        return ast

    def right_shift(self, ast):
        return ast

    def less_than(self, ast):
        return ast

    def greater_than(self, ast):
        return ast

    def less_than_or_equal(self, ast):
        return ast

    def greater_than_or_equal(self, ast):
        return ast

    def equals(self, ast):
        return ast

    def not_equals(self, ast):
        return ast

    def bit_wise_and(self, ast):
        return ast

    def bit_wise_xor(self, ast):
        return ast

    def bit_wise_or(self, ast):
        return ast

    def logical_and(self, ast):
        return ast

    def logical_or(self, ast):
        return ast

    def register_association_description(self, ast):
        return ast

    def register_association_string(self, ast):
        return ast

    def register_association_list(self, ast):
        return ast

    def reg_field_or_instance(self, ast):
        return ast

    def field_or_instance_name(self, ast):
        return ast

    def association_list(self, ast):
        return ast

    def port_list(self, ast):
        return ast

    def port_association_list(self, ast):
        return ast

    def info_list(self, ast):
        return ast

    def clock_list(self, ast):
        return ast

    def user_list(self, ast):
        return ast

    def user_list_name(self, ast):
        return ast

    def single_or_multi_list(self, ast):
        return ast

    def single_word_user_list(self, ast):
        return ast

    def multi_word_user_list(self, ast):
        return ast

    def unit(self, ast):
        return ast

    def unit_definition(self, ast):
        return ast

    def unit_name(self, ast):
        return ast

    def unit_value(self, ast):
        return ast

    def unit_scale(self, ast):
        return ast

    def unit_link(self, ast):
        return ast

    def power_port_association_description(self, ast):
        return ast

    def power_port_association_string(self, ast):
        return ast

    def power_port_association_list(self, ast):
        return ast

    def power_port_id(self, ast):
        return ast

    def bsdl_extensions(self, ast):
        return ast

    def extension_declaration(self, ast):
        return ast

    def extension_definition(self, ast):
        return ast

    def extension_name(self, ast):
        return ast

    def entity_defined_name(self, ast):
        return ast

    def bsdl_package_defined_name(self, ast):
        return ast

    def extension_parameter_string(self, ast):
        return ast

    def design_warning(self, ast):
        return ast

    def user_package(self, ast):
        return ast

    def user_package_stmt(self, ast):
        return ast

    def deferred_constant(self, ast):
        return ast

    def user_package_body(self, ast):
        return ast

    def cell_description_constant(self, ast):
        return ast

    def capture_descriptor_list(self, ast):
        return ast

    def capture_descriptor(self, ast):
        return ast

    def cell_context(self, ast):
        return ast

    def capture_instruction(self, ast):
        return ast

    def data_source(self, ast):
        return ast

    def asterisk(self, ast):
        return ast

    def colon(self, ast):
        return ast

    def colon_equal(self, ast):
        return ast

    def comma(self, ast):
        return ast

    def left_brace(self, ast):
        return ast

    def left_bracket(self, ast):
        return ast

    def left_paren(self, ast):
        return ast

    def minus_sign(self, ast):
        return ast

    def period(self, ast):
        return ast

    def quote(self, ast):
        return ast

    def right_brace(self, ast):
        return ast

    def right_bracket(self, ast):
        return ast

    def right_paren(self, ast):
        return ast

    def semicolon(self, ast):
        return ast


def main(filename, startrule, **kwargs):
    with open(filename) as f:
        text = f.read()
    parser = bsdlParser()
    return parser.parse(text, startrule, filename=filename, **kwargs)


if __name__ == '__main__':
    import json
    from grako.util import asjson

    ast = generic_main(main, bsdlParser, name='bsdl')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(asjson(ast), indent=2))
    print()
